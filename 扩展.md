## 关于C语言中的常量后面加u的解释

> 后缀就是告诉编译器该常数的属性。
默认为有符号INT型，加了u就是无符号的，加了l就是long型。
做下移位就知道结果了。以0x80为例，左移次数过多编译器会提示你符号位被改变，即负数被移位成正数。加个u的话就被编译器识别为无符号数，可以随意移位。不会影响符号位。

## 兼容5V
IO口可以接5V，FT都兼容5V，ADC不兼容5V
STM32F103RCT6的IO都是耐5V，意思是IO口既可以工作在3.3V电平，也可以工作在5V电平上。也称为可兼容5V。

## 计算机系统的体系结构
冯诺依曼和哈佛结构
程序指令和数据共用一个存储器，寻址和操作一起
程序指令和数据分开存储，对程序和数据可以同时操作
STM32单片机是哈佛结构

## 外部32.768K晶振作用
产生单片机所必须的时钟频率，单片机的一切指令的执行都是建立在这个基础上的，晶振的提供的时钟频率越高，那单片机的运行速度也就越快
可以作为RTC时钟源

## RTC (Real Time Clock)：实时时钟

RTC是个独立的定时器。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。

## RS232串口和USB
**串口**是计算机的一种通用的设备通信协议。其电气特性:
1）RS-232串口通信最远距离是50英尺；
2）RS232可做到双向传输，全双工通讯，最高传输速率20kbps 
3）RS-232C上传送的数字量采用负逻辑，且与地对称。
逻辑1:-3~-15V；逻辑0 : +3~+15V。
台式机电脑后面的9针接口就是com口(串口)。

**USB接口**
通用串行总线（英语：Universal Serial Bus，缩写：USB）是一种串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等数码产品。
1、可以热插拔。
2、USB2.0的速度可以达到480Mbps。
3、USB 3.0的理论速度为5.0Gb/s
4、USB4.0传输速度为40Gbit/s。

## C语言__weak关键字
在HAL库中出现__weak关键字修饰函数

weak 顾名思义是“弱”的意思，所以如果函数名称前面加上__weak 修饰符，我们一般称这个函数为“弱函数”。

加上了__weak 修饰符的函数，用户可以在用户文件中重新定义一个同名函数，最终编译器编译的时候，会选择用户定义的函数，如果用户没有重新定义这个函数，那么编译器就会执行__weak 声明的函数，并且编译器不会报错。

__weak是一个宏，和__packed是同一种东西都是gcc的扩展属性：

#define __packed __attribute__((packed))

#define __weak __attribute__((weak))

如果这个关键字用在函数定义上面，一般情况下和一般函数没有两样。但是当有一个同名函数但是不带__weak被定义时，所有对这个函数的调用都是指向后者(不带__weak那个), 如果有两个一样的函数都用了__weak,那么真正调用那个，就要看连接器了。

比如在串口通信中用到的接收中断回调函数
```c
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */
}
```
```c
#define UNUSED(X) (void)X      /* To avoid gcc/g++ warnings */
```
可以看到这个函数为了避免GCC的警告加了个 UNUSED(huart);这个函数并没有逻辑代码，而真正的逻辑代码是我们在调用回调函数时自己编写的，调用时候无需带__weak关键字

## __IO关键字

在HAL库中__IO是一个宏，代表关键字volatile，而volatile是C语言中的一个关键字

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
```c
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```
volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。
[参考文章](https://www.runoob.com/w3cnote/c-volatile-keyword.html)


